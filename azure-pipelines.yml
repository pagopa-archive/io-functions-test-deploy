variables:
  NODE_VERSION: '10.14.1'
  YARN_CACHE_FOLDER: $(Pipeline.Workspace)/.yarn

parameters:
  - name: 'TEST_ENABLE_DEPLOY'
    displayName: 'Enable deploy in test environment'
    type: boolean
    default: false

  - name: 'TEST_DEPLOY_TYPE'
    displayName: 'Method to achieve deployment in Test (if enabled):'
    type: string
    default: deployToTestSlot
    values:
      - deployToTestSlot  
      - deployToProductionSlot

  - name: 'PRODUCTION_ENABLE_DEPLOY'
    displayName: 'Enable deploy in production environment'
    type: boolean
    default: true

  - name: 'PRODUCTION_DEPLOY_TYPE'
    displayName: 'Method to achieve deployment in Production (if enabled):'
    type: string
    default: deployToStagingSlotAndSwap
    values:
      - deployToStagingSlot  
      - deployToProductionSlot
      - deployToStagingSlotAndSwap

  - name: 'RELEASE_SEMVER'
    displayName: 'When packing a release, define the version bump to apply'
    type: string
    values:
      - major
      - minor
      - patch
    default: minor

# Feature branches triggers the pipeline for pull request testing
# Master branch does't trigger the pipeline as it is meant to be the production branch
# Running the pipeline manually from master will deploy the application (see deploy stages for further conditions)
trigger:
  branches:
    include:
      - '*'
    exclude:
      - 'master'

# This pipeline has been implemented to be run on hosted agent pools based both
# on 'windows' and 'ubuntu' virtual machine images and using the scripts defined
# in the package.json file. Since we are deploying on Azure functions on Windows
# runtime, the pipeline is currently configured to use a Windows hosted image for
# the build and deploy.
pool:
  vmImage: 'windows-2019'

stages:
  # A) Build and code validation
  - stage: Build
    dependsOn: []
    jobs:
      # A1) Checkout, install module and build code
      - job: make_build      
        steps:
        - template: azure-templates/make-build-steps.yml
          parameters:
            make: build
            gitReference: $(Build.SourceVersion)

            
      # A2) Analyze source code to find errors with lint
      - job: lint
        pool:
          vmImage: 'ubuntu-latest'      
        steps:
        - template: azure-templates/make-build-steps.yml
          parameters:
            make: install_dependencies
            gitReference: $(Build.SourceVersion)

        - script: |
            yarn lint
          displayName: 'Lint'

      # A3) Validate API definition
      - job: lint_api
        pool:
          vmImage: 'ubuntu-latest'      
        steps:
        - script: |
            npx oval validate -p openapi/index.yaml
          displayName: 'Validate openAPI'

      # A4) Run Danger (skipping if not executing on a PR)
      - job: danger
        pool:
          vmImage: 'ubuntu-latest'
        condition: 
          and(
            succeeded(), 
            and(
              eq(variables['Build.Reason'], 'PullRequest'),
              ne(variables['DANGER_GITHUB_API_TOKEN'], 'skip')
            )
          )
        steps:
          - template: azure-templates/make-build-steps.yml
            parameters:
              make: install_dependencies
              gitReference: $(Build.SourceVersion)

          - bash: |
              yarn danger ci
            env:
              DANGER_GITHUB_API_TOKEN: '$(DANGER_GITHUB_API_TOKEN)'
            displayName: 'Danger CI'


  # B) Run unit tests if there is a push or pull request on any branch.
  - stage: Test
    dependsOn: []
    pool:
      vmImage: 'ubuntu-latest'
    jobs:
      - job: unit_tests
        steps:
        - template: azure-templates/make-build-steps.yml
          parameters:
            make: install_dependencies
            gitReference: "unused value"

        - script: |
            yarn test:coverage
          displayName: 'Unit tests exec'

        - bash: |
            bash <(curl -s https://codecov.io/bash)
          displayName: 'Code coverage'

  # C) Create a relase
  # Activated when all these are met:
  # - is a manual trigger
  # - is on branch master
  # - DO_RELEASE is true
  - stage: Release
    condition: 
      and(
        succeeded(),
        and (
          eq(variables['DO_RELEASE'], true),
          and(
            eq(variables['Build.SourceBranch'], 'refs/heads/master'),
            eq(variables['Build.Reason'], 'Manual')
          )
        )
      )  
    dependsOn:
      - Build
      - Test
    pool:
      vmImage: 'ubuntu-latest'
    jobs:
      - job: make_release      
        steps:
        - template: azure-templates/make-release-steps.yml
          parameters:
            semver: '${{ parameters.RELEASE_SEMVER }}'
            gitEmail: $(GIT_EMAIL)
            gitUsername: $(GIT_USERNAME)
            gitHubConnection: $(GITHUB_CONNECTION)

  # D) Deploy to TEST environment if the following conditions apply:
  #    - continuos deployment (automatic):
  #       - $DO_DEPLOY == true and TEST_ENABLE_DEPLOY == true
  #       - there is a push on 'master' branch 
  #    - manual deployment:
  #       - $DO_DEPLOY == true and TEST_ENABLE_DEPLOY == true
  - ${{ if eq(parameters.TEST_ENABLE_DEPLOY, true) }}:
    - stage: Deploy_test
      condition: 
        and(
          succeeded(),
          and (
            eq(variables['DO_DEPLOY'], true),
            eq(variables['Build.Reason'], 'Manual')
          )
        )    
      dependsOn:
        - Build
        - Test
        - Release
      jobs:
        - job: '${{ parameters.TEST_DEPLOY_TYPE }}'
          steps:
          - template: azure-templates/deploy-steps.yml
            parameters:
              deployType: '${{ parameters.TEST_DEPLOY_TYPE }}'
              azureSubscription: '$(TEST_AZURE_SUBSCRIPTION)'
              resourceGroupName: '$(TEST_RESOURCE_GROUP_NAME)'
              appName: '$(TEST_APP_NAME)'
              # The following condition is the same that triggers the Relase stage
              # The meaning is: if we did a Release, then the Build.SourceVersion doesn't reference the latest commit on master anymore
              # Hence we have to tell the task to pull from Github before building the code
              # As we do releases only from master, we can override the SourceVersion by just tell to pull from master
              ${{ if and(eq(variables['DO_RELEASE'], true),and(eq(variables['Build.SourceBranch'], 'refs/heads/master'),eq(variables['Build.Reason'], 'Manual'))) }}:
                gitReference: 'master'


  # E) Deploy to PRODUCTION environment if one of the following conditions apply:
  #    - continuos deployment (automatic):
  #       - $DO_DEPLOY == true and PRODUCTION_ENABLE_DEPLOY == true
  #       - the 'latest' tag is pushed 
  #    - manual deployment:
  #       - $DO_DEPLOY == true and PRODUCTION_ENABLE_DEPLOY == true
  - ${{ if eq(parameters.PRODUCTION_ENABLE_DEPLOY, true) }}:
    - stage: Deploy_production
      condition: 
        and(
          succeeded(),
          and (
            eq(variables['DO_DEPLOY'], true),
            eq(variables['Build.Reason'], 'Manual')
          )
        )
      dependsOn:
        - Build
        - Test
        - Release
      jobs:
        - job: '${{ parameters.PRODUCTION_DEPLOY_TYPE }}'
          steps:
          - template: azure-templates/deploy-steps.yml
            parameters:
              deployType: '${{ parameters.PRODUCTION_DEPLOY_TYPE }}'
              azureSubscription: '$(PRODUCTION_AZURE_SUBSCRIPTION)'
              resourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
              appName: '$(PRODUCTION_APP_NAME)'
              # The following condition is the same that triggers the Relase stage
              # The meaning is: if we did a Release, then the Build.SourceVersion doesn't reference the latest commit on master anymore
              # Hence we have to tell the task to pull from Github before building the code
              # As we do releases only from master, we can override the SourceVersion by just tell to pull from master
              ${{ if and(eq(variables['DO_RELEASE'], true),and(eq(variables['Build.SourceBranch'], 'refs/heads/master'),eq(variables['Build.Reason'], 'Manual'))) }}:
                gitReference: 'master'

